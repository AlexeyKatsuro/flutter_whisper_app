# Code Style and Naming Rules

## Code Formatting

### Dart Formatter Configuration
- **Line length**: 100 characters (configured in `analysis_options.yaml`)
- **Trailing commas**: Preserve existing trailing commas
- **Linting**: Use `sizzle_lints` package for comprehensive linting rules

### Formatting Commands
```bash
# Format with line length 100
dart format --line-length 100 lib/ test/

# Exclude generated files
find lib test -name '*.dart' ! -name '*.*.dart' -exec dart format --line-length 100 {} +
```

## Naming Conventions

### Files and Directories
- **Files**: `snake_case.dart` (e.g., `user_profile.dart`, `settings_bloc.dart`)
- **Directories**: `snake_case` (e.g., `user_management/`, `data_sources/`)
- **Generated files**: `*.g.dart`, `*.freezed.dart` patterns (excluded from formatting)

### Classes and Types
- **Classes**: `PascalCase` (e.g., `UserProfile`, `SettingsBloc`, `ThemeConfiguration`)
- **Abstract classes**: Prefix with descriptive intent (e.g., `SettingsRepository`, `BaseLogger`)
- **Implementation classes**: Suffix with `Impl` (e.g., `SettingsRepositoryImpl`)
- **Test classes**: Suffix with `Test` (e.g., `SettingsBlocTest`)
- **Mixins**: `PascalCase` with descriptive name (e.g., `ValidationMixin`)
- **Extensions**: `PascalCase` with `Extension` suffix (e.g., `StringExtension`)
- **Enums**: `PascalCase` for enum type, `camelCase` for values (e.g., `ThemeMode.light`)

### Variables and Functions
- **Variables**: `camelCase` (e.g., `userProfile`, `currentTheme`)
- **Constants**: `camelCase` for local, `lowerCamelCase` for class constants (e.g., `const apiTimeout = 30`)
- **Static constants**: `camelCase` (e.g., `static const defaultTimeout = 30`)
- **Functions**: `camelCase` (e.g., `getUserProfile()`, `updateSettings()`)
- **Private members**: Prefix with `_` (e.g., `_internalState`, `_calculateValue()`)

### Packages and Libraries
- **Package names**: `snake_case` (e.g., `settings_api`, `user_management`)
- **Library exports**: Use descriptive names in export file (e.g., `settings_api.dart`)

## Class Structure and Patterns

### Class Definition Order
1. **Class documentation** (if applicable)
2. **Constructors** (const constructor first, then named constructors)
3. **Static members** (constants, static methods)
4. **Instance fields** (final fields first, then mutable)
5. **Getters and setters**
6. **Instance methods** (public first, then private)
7. **Overridden methods** (`toString`, `==`, `hashCode`)

### Immutability Patterns
**Use Freezed for immutable data classes to eliminate boilerplate.** See `freezed_patterns.mdc` for comprehensive guidelines.

```dart
@freezed
class UserProfile with _$UserProfile {
  const factory UserProfile({
    required String id,
    required String name,
    required String email,
    String? avatar,
  }) = _UserProfile;

  factory UserProfile.fromJson(Map<String, dynamic> json) => _$UserProfileFromJson(json);
}
```

**When to use Freezed vs manual implementation:**
- **Use Freezed**: Data models, BLoC states/events, API response models, exception classes
- **Use manual**: Simple value objects, custom behavior classes, performance-critical classes

### Constructor Patterns
**For Freezed classes** (see `freezed_patterns.mdc` for details):
- Use factory constructors with named parameters
- Mark essential fields as `required`
- Use `@Default()` annotation for default values

**For manual classes:**
- Use const constructors when possible
- Named parameters for multiple parameters
- Required parameters for essential fields
- Default values for optional parameters

```dart
const UserSettings({
  required this.theme,
  required this.locale,
  this.notifications = true,
  this.analyticsEnabled = false,
});
```

### Access Modifiers
- **Public API**: No prefix, document with dartdoc comments
- **Internal/Private**: Use `_` prefix for implementation details
- **Package-private**: Place in `src/` directory, don't export publicly

## Error Handling Patterns

### Exception Classes
**Use Freezed for exception hierarchies** (see `freezed_patterns.mdc` for detailed patterns):

```dart
@freezed
sealed class SettingsException with _$SettingsException implements Exception {
  const factory SettingsException.save({required String message, Object? cause}) = SettingsSaveException;
  const factory SettingsException.load({required String message, Object? cause}) = SettingsLoadException;
  const factory SettingsException.validation({required String message, required String field}) = SettingsValidationException;
}
```

**For manual exception classes:**
```dart
sealed class SettingsException implements Exception {
  const SettingsException({required this.message});
  final String message;
  @override
  String toString() => 'SettingsException: $message';
}
```

### Error Handling in Methods
```dart
Future<void> saveSettings(Settings settings) async {
  try {
    await _repository.save(settings);
  } on StorageException catch (e) {
    throw SettingsSaveException(
      message: 'Failed to save settings: ${e.message}',
      cause: e,
    );
  } catch (e) {
    throw SettingsSaveException(
      message: 'Unexpected error saving settings',
      cause: e,
    );
  }
}
```

## Documentation Standards

### Class Documentation
```dart
/// {@template user_profile}
/// Represents a user's profile information including personal details
/// and preferences.
/// 
/// This class is immutable and provides [copyWith] method for updates.
/// {@endtemplate}
final class UserProfile {
  /// {@macro user_profile}
  const UserProfile({required this.id, required this.name});
  
  /// Unique identifier for the user.
  final String id;
  
  /// Display name of the user.
  final String name;
}
```

### Method Documentation
```dart
/// Updates the user's display name.
/// 
/// Throws [ValidationException] if [name] is empty or invalid.
/// Returns a new [UserProfile] instance with the updated name.
UserProfile updateName(String name) {
  if (name.trim().isEmpty) {
    throw ValidationException('Name cannot be empty');
  }
  return copyWith(name: name);
}
```

## Import Organization

### Import Order
1. **Dart SDK imports** (e.g., `dart:async`, `dart:io`)
2. **Flutter framework imports** (e.g., `package:flutter/material.dart`)
3. **Code generation imports** (e.g., `package:freezed_annotation/freezed_annotation.dart`)
4. **External package imports** (alphabetical)
5. **Internal package imports** (alphabetical)
6. **Part directives** (for generated files)
7. **Relative imports** (use sparingly)

### Import Style
```dart
import 'dart:async';

import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:freezed_annotation/freezed_annotation.dart';

import 'package:common/common.dart';
import 'package:settings_api/settings_api.dart';

part 'user_profile.freezed.dart';
part 'user_profile.g.dart';

import '../models/user_profile.dart';
```

## Widget and UI Patterns

### Widget Class Structure
```dart
class SettingsScreen extends StatefulWidget {
  const SettingsScreen({super.key});
  
  @override
  State<SettingsScreen> createState() => _SettingsScreenState();
}

class _SettingsScreenState extends State<SettingsScreen> {
  // Private methods for handling user interactions
  void _onThemeChanged(ThemeMode theme) {
    final bloc = SettingsScope.blocOf(context);
    bloc.add(SettingsEvent.updateTheme(theme: theme));
  }
  
  // Private methods for building UI components
  Widget _buildThemeSelector() {
    return /* widget implementation */;
  }
  
  @override
  Widget build(BuildContext context) {
    return Scaffold(/* main UI */);
  }
}
```

### Private Widget Pattern
Use private widgets for complex UI components within a file:
```dart
class _ThemeSelector extends StatelessWidget {
  const _ThemeSelector({required this.onChanged});
  
  final ValueChanged<ThemeMode> onChanged;
  
  @override
  Widget build(BuildContext context) {
    return /* implementation */;
  }
}
```

## Testing Conventions

### Test File Naming
- **Test files**: `{source_file}_test.dart` (e.g., `settings_bloc_test.dart`)
- **Test directories**: Mirror source structure in `test/` directory

### Test Class Naming
```dart
void main() {
  group('SettingsBloc', () {
    group('constructor', () {
      test('initializes with correct initial state', () {
        // Test implementation
      });
    });
    
    group('updateSettings', () {
      test('emits loading then success states', () async {
        // Test implementation  
      });
    });
  });
}
```

## Code Generation

### Freezed Usage
Use Freezed for data models, BLoC states/events, and exception classes. See `freezed_patterns.mdc` for comprehensive guidelines including:
- Setup and dependencies
- Basic and advanced patterns  
- JSON serialization with custom converters
- BLoC-specific patterns
- Exception hierarchies

### Code Generation Workflow
After modifying Freezed classes, always run:
```bash
bash scripts/bootstrap.bash
```

## Performance and Best Practices

### Const Usage
- Use `const` constructors and widgets whenever possible
- Mark collections as `const` when they don't change
- Use `const` for default values in constructors
- With Freezed, const constructors are generated automatically

### Memory Management
- Dispose of streams, controllers, and listeners in `dispose()`
- Use weak references for callbacks when appropriate
- Avoid memory leaks in long-running operations
- Freezed classes are immutable by default, reducing memory allocation issues

### Null Safety
- Use nullable types (`Type?`) only when null is a valid state
- Prefer non-nullable types with default values
- Use null-aware operators (`??`, `?.`, `??=`) appropriately
- Avoid `!` operator except when you're certain value is non-null
- Use `@Default()` annotation in Freezed for non-null default values
