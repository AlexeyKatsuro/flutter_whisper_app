# BLoC State Management Patterns

## BLoC Architecture Overview

### Global BLoC Configuration
The application uses BLoC for state management with these global configurations:

```dart
// In startup.dart
Bloc.observer = AppBlocObserver(logger);
Bloc.transformer = SequentialBlocTransformer<Object?>().transform;
```

### BLoC Observer Pattern
Use `AppBlocObserver` for centralized logging of all BLoC events and state changes:

```dart
class AppBlocObserver extends BlocObserver {
  const AppBlocObserver(this.logger);
  
  final Logger logger;
  
  @override
  void onTransition(Bloc<Object?, Object?> bloc, Transition<Object?, Object?> transition) {
    // Log state transitions with limited string length
    final logMessage = StringBuffer()
      ..writeln('Bloc: ${bloc.runtimeType}')
      ..writeln('Event: ${transition.event.runtimeType}')
      ..writeln('Transition: ${transition.currentState.runtimeType} => ${transition.nextState.runtimeType}')
      ..write('New State: ${transition.nextState?.toString().limit(100)}');
    
    logger.info(logMessage.toString());
    super.onTransition(bloc, transition);
  }
}
```

## BLoC Implementation Patterns

### Basic BLoC Structure
```dart
final class FeatureBloc extends Bloc<FeatureEvent, FeatureState> {
  FeatureBloc({
    required FeatureRepository repository,
    required FeatureState initialState,
  }) : _repository = repository,
       super(initialState) {
    on<FeatureEvent>(
      (event, emit) => switch (event) {
        final _CreateEvent e => _handleCreate(e, emit),
        final _UpdateEvent e => _handleUpdate(e, emit),
        final _DeleteEvent e => _handleDelete(e, emit),
      },
    );
  }
  
  final FeatureRepository _repository;
  
  Future<void> _handleUpdate(
    _UpdateEvent event,
    Emitter<FeatureState> emit,
  ) async {
    try {
      emit(FeatureState.loading(data: state.data));
      final result = await _repository.update(event.data);
      emit(FeatureState.success(data: result));
    } catch (error) {
      emit(FeatureState.error(error: error, data: state.data));
    }
  }
}
```

### Event Patterns
Use sealed classes for type-safe event handling:

```dart
sealed class FeatureEvent {
  const FeatureEvent();
  
  /// Creates a new feature item
  const factory FeatureEvent.create({required FeatureData data}) = _CreateEvent;
  
  /// Updates an existing feature item
  const factory FeatureEvent.update({required FeatureData data}) = _UpdateEvent;
  
  /// Deletes a feature item
  const factory FeatureEvent.delete({required String id}) = _DeleteEvent;
}

final class _CreateEvent extends FeatureEvent {
  const _CreateEvent({required this.data});
  
  final FeatureData data;
  
  @override
  String toString() => 'FeatureEvent.create(data: $data)';
}

final class _UpdateEvent extends FeatureEvent {
  const _UpdateEvent({required this.data});
  
  final FeatureData data;
  
  @override
  String toString() => 'FeatureEvent.update(data: $data)';
}

final class _DeleteEvent extends FeatureEvent {
  const _DeleteEvent({required this.id});
  
  final String id;
  
  @override
  String toString() => 'FeatureEvent.delete(id: $id)';
}
```

### State Patterns
Implement states with data preservation and clear status indication:

```dart
sealed class FeatureState {
  const FeatureState({this.data});
  
  /// The current data (preserved across state changes)
  final FeatureData? data;
  
  /// Initial/idle state
  const factory FeatureState.idle({FeatureData? data}) = _IdleState;
  
  /// Loading state (operation in progress)
  const factory FeatureState.loading({FeatureData? data}) = _LoadingState;
  
  /// Success state (operation completed)
  const factory FeatureState.success({required FeatureData data}) = _SuccessState;
  
  /// Error state (operation failed)
  const factory FeatureState.error({
    required Object error,
    FeatureData? data,
  }) = _ErrorState;
}

final class _IdleState extends FeatureState {
  const _IdleState({super.data});
  
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is _IdleState && other.data == data;
  
  @override
  int get hashCode => data.hashCode;
  
  @override
  String toString() => 'FeatureState.idle(data: $data)';
}

final class _LoadingState extends FeatureState {
  const _LoadingState({super.data});
  
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is _LoadingState && other.data == data;
  
  @override
  int get hashCode => data.hashCode;
  
  @override
  String toString() => 'FeatureState.loading(data: $data)';
}

final class _ErrorState extends FeatureState {
  const _ErrorState({required this.error, super.data});
  
  final Object error;
  
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is _ErrorState && 
          other.error == error && 
          other.data == data;
  
  @override
  int get hashCode => Object.hash(error, data);
  
  @override
  String toString() => 'FeatureState.error(error: $error, data: $data)';
}
```

## State Access Patterns

### Scope-Based State Access
Provide BLoC access through feature scopes:

```dart
class FeatureScope extends StatefulWidget {
  const FeatureScope({
    required this.featureContainer,
    required this.child,
    super.key,
  });
  
  final FeatureContainer featureContainer;
  final Widget child;
  
  /// Get the feature BLoC from the scope
  static FeatureBloc blocOf(BuildContext context, {bool listen = true}) {
    final scope = listen
        ? context.dependOnInheritedWidgetOfExactType<_FeatureInherited>()
        : context.getInheritedWidgetOfExactType<_FeatureInherited>();
    
    if (scope == null) {
      throw Exception('FeatureScope not found');
    }
    
    return scope.featureContainer.featureBloc;
  }
  
  /// Get the current feature state from the scope
  static FeatureState stateOf(BuildContext context, {bool listen = true}) {
    final scope = of(context, listen: listen);
    return scope.state;
  }
  
  /// Get the feature data from the scope
  static FeatureData? dataOf(BuildContext context, {bool listen = true}) {
    final scope = of(context, listen: listen);
    return scope.state.data;
  }
  
  @override
  State<FeatureScope> createState() => _FeatureScopeState();
}

class _FeatureScopeState extends State<FeatureScope> {
  late final StreamSubscription<FeatureState> _subscription;
  late FeatureState _state;
  
  @override
  void initState() {
    super.initState();
    _state = widget.featureContainer.featureBloc.state;
    _subscription = widget.featureContainer.featureBloc.stream.listen((state) {
      setState(() {
        _state = state;
      });
    });
  }
  
  @override
  void dispose() {
    _subscription.cancel();
    super.dispose();
  }
  
  @override
  Widget build(BuildContext context) {
    return _FeatureInherited(
      featureContainer: widget.featureContainer,
      state: _state,
      child: widget.child,
    );
  }
}
```

### Widget State Integration
Use BLoC in widgets with proper error handling and loading states:

```dart
class FeatureWidget extends StatefulWidget {
  const FeatureWidget({super.key});
  
  @override
  State<FeatureWidget> createState() => _FeatureWidgetState();
}

class _FeatureWidgetState extends State<FeatureWidget> {
  void _handleUserAction(FeatureData data) {
    final bloc = FeatureScope.blocOf(context);
    bloc.add(FeatureEvent.update(data: data));
  }
  
  @override
  Widget build(BuildContext context) {
    final state = FeatureScope.stateOf(context);
    
    return switch (state) {
      _LoadingState() => const CircularProgressIndicator(),
      _ErrorState(:final error) => _buildErrorWidget(error),
      _SuccessState(:final data) => _buildSuccessWidget(data),
      _IdleState(:final data) => _buildIdleWidget(data),
    };
  }
  
  Widget _buildErrorWidget(Object error) {
    return Column(
      children: [
        Text('Error: $error'),
        ElevatedButton(
          onPressed: () => _handleRetry(),
          child: const Text('Retry'),
        ),
      ],
    );
  }
  
  Widget _buildSuccessWidget(FeatureData data) {
    return Column(
      children: [
        Text('Data: ${data.title}'),
        ElevatedButton(
          onPressed: () => _handleUserAction(data.copyWith(title: 'Updated')),
          child: const Text('Update'),
        ),
      ],
    );
  }
}
```

## Event Transformation and Sequential Processing

### Sequential Event Processing
Use `SequentialBlocTransformer` to process events one at a time:

```dart
abstract base class BlocTransformer<Event> {
  Stream<Event> transform(Stream<Event> stream, EventMapper<Event> mapper);
}

final class SequentialBlocTransformer<Event> extends BlocTransformer<Event> {
  @override
  Stream<Event> transform(Stream<Event> stream, EventMapper<Event> mapper) =>
      stream.asyncExpand(mapper);
}

// Global configuration
Bloc.transformer = SequentialBlocTransformer<Object?>().transform;
```

### Custom Event Transformers (when needed)
For specific BLoCs that need different event processing:

```dart
final class DebounceTransformer<Event> extends BlocTransformer<Event> {
  const DebounceTransformer({this.duration = const Duration(milliseconds: 300)});
  
  final Duration duration;
  
  @override
  Stream<Event> transform(Stream<Event> stream, EventMapper<Event> mapper) {
    return stream
        .debounceTime(duration)
        .asyncExpand(mapper);
  }
}

// Use in specific BLoC
class SearchBloc extends Bloc<SearchEvent, SearchState> {
  SearchBloc() : super(SearchState.initial()) {
    on<SearchEvent>(
      _handleSearch,
      transformer: DebounceTransformer<SearchEvent>().transform,
    );
  }
}
```

## Error Handling in BLoCs

### Repository Error Handling
Handle repository errors gracefully in BLoC methods:

```dart
Future<void> _handleUpdate(
  _UpdateEvent event,
  Emitter<FeatureState> emit,
) async {
  try {
    emit(FeatureState.loading(data: state.data));
    await _repository.update(event.data);
    emit(FeatureState.success(data: event.data));
  } on ValidationException catch (e) {
    emit(FeatureState.error(
      error: 'Validation failed: ${e.message}',
      data: state.data,
    ));
  } on NetworkException catch (e) {
    emit(FeatureState.error(
      error: 'Network error: ${e.message}',
      data: state.data,
    ));
  } catch (error) {
    emit(FeatureState.error(
      error: 'Unexpected error: $error',
      data: state.data,
    ));
  }
}
```

### State Preservation During Errors
Always preserve current data when transitioning to error states:

```dart
// Good: Preserve data during error
emit(FeatureState.error(error: error, data: state.data));

// Bad: Lose data during error
emit(FeatureState.error(error: error));
```

## Testing BLoCs

### BLoC Test Structure
```dart
void main() {
  group('FeatureBloc', () {
    late FeatureRepository mockRepository;
    late FeatureBloc bloc;
    
    setUp(() {
      mockRepository = MockFeatureRepository();
      bloc = FeatureBloc(
        repository: mockRepository,
        initialState: const FeatureState.idle(),
      );
    });
    
    tearDown(() {
      bloc.close();
    });
    
    group('constructor', () {
      test('initial state is idle', () {
        expect(bloc.state, equals(const FeatureState.idle()));
      });
    });
    
    group('update event', () {
      test('emits loading then success when repository succeeds', () async {
        // Arrange
        const testData = FeatureData(id: '1', title: 'Test');
        when(() => mockRepository.update(any()))
            .thenAnswer((_) async => testData);
        
        // Assert
        expectLater(
          bloc.stream,
          emitsInOrder([
            const FeatureState.loading(),
            const FeatureState.success(data: testData),
          ]),
        );
        
        // Act
        bloc.add(const FeatureEvent.update(data: testData));
      });
      
      test('emits loading then error when repository fails', () async {
        // Arrange
        const testData = FeatureData(id: '1', title: 'Test');
        const error = 'Repository error';
        when(() => mockRepository.update(any()))
            .thenThrow(error);
        
        // Assert
        expectLater(
          bloc.stream,
          emitsInOrder([
            const FeatureState.loading(),
            const FeatureState.error(error: error),
          ]),
        );
        
        // Act
        bloc.add(const FeatureEvent.update(data: testData));
      });
    });
  });
}
```

## Performance Considerations

### Efficient State Updates
- Preserve data across state transitions to avoid rebuilds
- Use `==` operator implementations for proper state comparison
- Avoid emitting the same state consecutively

### Memory Management
- Close BLoCs in container disposal
- Use stream subscriptions carefully in scope widgets
- Cancel subscriptions in widget dispose methods

### UI Optimization
- Use selective listening with `listen: false` when appropriate
- Implement efficient widget rebuilds with proper state checks
- Cache expensive computations in state objects
